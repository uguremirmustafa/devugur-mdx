---
title: React Projenize Typescript ile Level AtlatÄ±n
summary: Typescript bizleri birÃ§ok hatadan kurtarmakla kalmÄ±yor bizlere zaman da kazandÄ±rÄ±yor. Gelin React projenizde Typescript'i nasÄ±l kullanabilirsiniz bakalÄ±m.
publishedAt: '2021-10-26'
image: '/images/blog/react-ve-typescript/kapak.png'
locale: tr
tags: ['typescript', 'react']
isPublished: true
alternate: ''
type: blog
selected: true
---

Typescriptin bizlere saÄŸladÄ±ÄŸÄ± nimetleri saymakla vakit kaybetmeyi hiÃ§ istemiyorum. Zaten bÃ¼yÃ¼k ihtimalle bu nimetlerden haberi olan birisi olarak buraya geldin. O yÃ¼zden hemen baÅŸlamak istiyorum.

## Typescript-React Boilerplate

Her ÅŸeyden Ã¶nce hÄ±zlÄ±ca bir React-Typescript boilerplate'i ile baÅŸlayalÄ±m. Webpack, Babel vs. ile uÄŸraÅŸmadan `create-react-app` ile bir proje oluÅŸturalÄ±m. Åablon olarak `typescript` seÃ§meyi unutmayÄ±n. ğŸ‘‡

```bash
npx create-react-app <proje_adÄ±> --template typescript
```

YukarÄ±daki komut Ã§alÄ±ÅŸmasÄ±nÄ± tamamladÄ±ÄŸÄ±nda React-Typescript boilerplate kodumuz hazÄ±r olacak. ArdÄ±ndan proje dizinine gidip editÃ¶rÃ¼mÃ¼zÃ¼ aÃ§alÄ±m.

> EÄŸer halihazÄ±rda Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ±z bir React projesine Typescript eklemek isterseniz [ÅŸurayÄ±](https://create-react-app.dev/docs/adding-typescript/#installation) okuyabilirsiniz.

Ã‡alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±z kod bize her zamanki alÄ±ÅŸÄ±k olduÄŸumuz `.jsx` uzantÄ±lÄ± dosyalarÄ±n yerine `.tsx` uzantÄ±lÄ± dosyalar yarattÄ±. Bu formata sahip dosyalarda typescript ve jsx kodunu birlikte yazabileceÄŸiz.

## Component Yaratma

Typescript ile yeni bir component yaratmayÄ± deneyelim. Component'imiz bir `Container` olsun. Bu container property olarak `size` adÄ±nda bir `string` alsÄ±n. AyrÄ±ca `children` componentleri iÃ§ine alabilsin.

```tsx
// components/Container.tsx

import { ReactNode } from 'react';

export type Sizes = 'sm' | 'md' | 'lg';

interface Props {
  size: Sizes;
  children: ReactNode;
}

const Container = ({ size, children }: Props) => {
  return <div className={size}>{children}</div>;
};

export default Container;
```

Burada neler oluyor bir bakalÄ±m.

1. Ä°lk dikkatimizi Ã§eken `interface` ve `type` anahtar kelimeleri olmuÅŸtur sanÄ±rÄ±m. Typescript ve React ile Ã§alÄ±ÅŸÄ±rken bu anahtar kelimeler Ã§ok sÄ±k rastlayacaÄŸÄ±nÄ±zÄ± unutmayÄ±n. Bunlar Typescript type'larÄ±nÄ± tanÄ±mlamak iÃ§in kullandÄ±ÄŸÄ±mÄ±z anahtar kelimeler. Ä°kisinin arasÄ±nda bazÄ± farklar olsa da ikisi genelde birbirinin yerine kullanÄ±lmakta. Bu konuda karar vermekte zorlanÄ±yorsanÄ±z `type`'Ä± kullanmak zorunda kalana kadar `interface`'i kullanmaya devam edin diyebilirim.

_Sizes_ adÄ±nda tanÄ±mlamÄ±ÅŸ olduÄŸumuz _union_ type ile size property'sinin alabileceÄŸi string deÄŸerleri sÄ±nÄ±rlÄ± bir ÅŸekilde belirtmiÅŸ oluyoruz. EÄŸer birisi burada sÄ±ralanan 'sm' | 'md' | 'lg' seÃ§eneklerinden baÅŸka bir seÃ§enek sunmak isterse typescript bunu yakalayacaktÄ±r.

2. Dikkat Ã§eken diÄŸer bir nokta ise `children` type olmalÄ±. Zira React ile Typescript kullanÄ±rken children prop'unu Ã§eÅŸitli ÅŸekillerde tanÄ±mlayabilmekteyiz.

- ReactChild
- ReactChild[]
- ReactNode
- `const Page: React.FC<Props\> = ({ title, children }) => {}`

Bu seÃ§enekler arasÄ±nda bazÄ± farklÄ±lÄ±klar mevcut ama konumuzun sÄ±nÄ±rlarÄ±nÄ± aÅŸtÄ±ÄŸÄ± iÃ§in bunu farklÄ± bir yazÄ±ya saklÄ±yorum. EÄŸer merak ediyorsanÄ±z [ÅŸu](https://www.carlrippon.com/react-children-with-typescript/) makaleye gÃ¶z atabilirsiniz.

Åimdi de bu komponenti App.tsx dosyamÄ±zda kullanalÄ±m.

```tsx
// App.tsx

import Container from './components/Container';

function App() {
  return (
    <div>
      <Container size="sm">
        <h2>hello world</h2>
      </Container>
    </div>
  );
}

export default App;
```

Ä°ÅŸte bu kadar basit. EÄŸer parent dosyamÄ±zdan yani App.tsx'ten size property'sini girmezsek typescript compiler bize hata verecektir. Zira size property'nin zorunlu bir prop olduÄŸunu `Container` componentimizin `interface`'inde belirtmiÅŸtik. EÄŸer bu property'nin optinal(yani isteÄŸe baÄŸlÄ±) olmasÄ±nÄ± istiyorsak bir _soru iÅŸareti(?)_ iÅŸimizi gÃ¶recektir.

```tsx
//...
interface Props {
  size?: Sizes;
  //...
}
```

AynÄ± durum componente children eklemediÄŸimiz durumda da karÅŸÄ±mÄ±za Ã§Ä±kacaktÄ±r Ã§Ã¼nkÃ¼ her zaman children alacaÄŸÄ±nÄ± sÃ¶ylediÄŸimiz bir component yarattÄ±k. Ä°stersek onu da soru iÅŸareti ile optional hale getirebiliriz.

## Typescript ve useState Hook

State'imizin type'Ä±nÄ± belirlemek bizleri olasÄ± hatalÄ± state gÃ¼ncellemelerinden ve benzer diÄŸer hatalardan kurtaracaktÄ±r. `useState` hook ile typescripti aÅŸaÄŸÄ±daki syntax ile kullanabiliriz.

```tsx
interface User {
  name: string;
  email: string;
  address: {
    city: string;
    street?: string;
    apartmentNumber?: number;
  };
  hobbies?: string[];
}

const Container = ({ size, children }: Props) => {
  const [user, setUser] = useState<User>();
  return <div className={size}>{children}</div>;
};

export default Container;
```

`useState`'in type'Ä±nÄ± bu ÅŸekilde belirttiÄŸimizde `ctrl` + `space` kombinasyonu bizlere otomatik tamamlama seÃ§eneklerini gÃ¶steriyor. Bu ÅŸekilde yazÄ±m hatalarÄ± vb. tamamen engellenmiÅŸ oluyor.

![autocomplete](./autocomplete.png)

EÄŸer _user_ state'inin zorunlu Ã¶gelerinden biri eksik girilseydi de aynÄ± ÅŸekilde typescript engine bizi uyaracaktÄ±. Bana sorarsanÄ±z bu ÅŸekilde Ã§alÄ±ÅŸmak hem daha zevkli hem de daha gÃ¼venli.

## Typescript ve useRef Hook

`useRef` vanilla javascriptte sÄ±klÄ±kla kullandÄ±ÄŸÄ±mÄ±z `getElementById` veya `querySelector` yerine React ortamÄ±nda kullanÄ±mÄ± tercih edilen bir hook yapÄ±sÄ± olarak karÅŸÄ±mÄ±za Ã§Ä±kÄ±yor. DOM node'larÄ±nÄ± seÃ§mek iÃ§in kullanÄ±lan `useRef` typescript ile nasÄ±l kullanÄ±lÄ±r kÄ±saca inceleyelim. Ã–ncelikle bir tane `input` field ekleyelim ve bu input field'Ä± useRef ile seÃ§elim. ArdÄ±ndan da _focus_ ve _blur_ eventleri trigger olduÄŸunda style deÄŸiÅŸikliÄŸi yapalÄ±m.

![input field](./inputfield.gif)

```tsx
import React, { useLayoutEffect, useRef } from 'react';
import styles from './InputField.module.css';
interface Props {}

const InputField = (props: Props) => {
  const inputRef = useRef<HTMLInputElement>(null);
  useLayoutEffect(() => {
    const { current } = inputRef;

    const handleFocus = () => inputRef.current?.classList.add(styles.active);
    const handleBlur = () => inputRef.current?.classList.remove(styles.active);

    current?.addEventListener('focus', handleFocus);
    current?.addEventListener('blur', handleBlur);

    return () => {
      current?.removeEventListener('focus', handleFocus);
      current?.removeEventListener('blur', handleBlur);
    };
  }, []);
  return (
    <div>
      <input ref={inputRef} type="text" className={styles.input} />
    </div>
  );
};

export default InputField;
```

Evet, burada birÃ§ok olay gerÃ§ekleÅŸiyor. HerÅŸeyden Ã¶nce `useLayoutEffect` yabancÄ± geliyorsa merak etmeyin `useEffect` ile neredeyse aynÄ± fakat sadece DOM node'larÄ±ndaki deÄŸiÅŸiklikler iÃ§in kullanÄ±lÄ±yor. %99 useEffect ile aynÄ± amaca hizmet ediyor, o yÃ¼zden no-panic!

![dont panic](./giphy.webp)

`useRef` hook kullanÄ±rken genelde bir constanta tanÄ±mlanÄ±r. Burada da inputRef olarak tanÄ±mladÄ±k. Typescript type'Ä±nÄ± ise useState'de yaptÄ±ÄŸÄ±mÄ±z gibi `useRef<HTMLInputElement>` ÅŸeklinde tanÄ±mlÄ±yoruz. `HTMLInputElement` ÅŸeklinde tanÄ±mlamamÄ±zÄ±n sebebi ise referansta bulunduÄŸumuz DOM elementinin bir `input` olmasÄ±. EÄŸer bunu nasÄ±l bulacaÄŸÄ±nÄ±zÄ± bilmiyorsanÄ±z Typescript'in bir numaralÄ± kuralÄ±nÄ± hatÄ±rlayÄ±n: HOVER OVER!

```tsx
const inputRef = useRef<HTMLInputElement>(null);
```

Evet, type'Ä±nÄ± bilmediÄŸiniz bir element mi var, hemen fareyi ilgili alanÄ±n Ã¼zerine getirin, IDE'niz size yapmanÄ±z gerekeni sÃ¶yleyecektir.

`useLayoutEffect` ile component mount olduÄŸunda inputRef'in referans ettiÄŸi `input` DOM tree'ye yÃ¼klenmiÅŸ oluyor. BÃ¶ylece inputRef'i destructure ettiÄŸimizde bizim iÅŸimize en Ã§ok yarayacak `current` property'sine eriÅŸebiliyoruz.

```tsx
const { current } = inputRef;

const handleFocus = () => inputRef.current?.classList.add(styles.active);

const handleBlur = () => inputRef.current?.classList.remove(styles.active);
```

ArdÄ±ndan `.active` classÄ±nÄ± input elementine ekleyip Ã§Ä±karan iki fonksiyon tanÄ±mlÄ±yoruz. ArdÄ±ndan input elementi Ã¼zerinde _focus_ ve _blur_ eventlerini dinliyor ve bu eventler trigger olduÄŸunda az Ã¶nce tanÄ±mladÄ±ÄŸÄ±mÄ±z fonksiyonlarÄ± Ã§aÄŸÄ±rÄ±yoruz.

```tsx
current?.addEventListener('focus', handleFocus);
current?.addEventListener('blur', handleBlur);
```

En sonunda ise eventListener'larÄ± hafÄ±zadan silmek iÃ§in bir fonksiyon Ã§aÄŸÄ±rÄ±yoruz.

```tsx
return () => {
  current?.removeEventListener('focus', handleFocus);
  current?.removeEventListener('blur', handleBlur);
};
```

Evet `useRef` ve Typescript bu kadar kolay. DiÄŸer DOM nodelarÄ±nÄ± ref ile seÃ§tiÄŸinizde angle bracket iÃ§ine ne koyacaÄŸÄ±nÄ±zÄ± aÅŸaÄŸÄ±da gÃ¶rebilirsiniz. ğŸ‘‡

```tsx
// <div/>
const divRef = React.useRef<HTMLDivElement>(null);

// <button/>
const buttonRef = React.useRef<HTMLButtonElement>(null);

// <br />
const brRef = React.useRef<HTMLBRElement>(null);

// <a>
const linkRef = React.useRef<HTMLLinkElement>(null);
```

## SonuÃ§

Evet, bu yazÄ±da React ile Typescript kullanÄ±rken sÄ±klÄ±kla karÅŸÄ±laÅŸacaÄŸÄ±mÄ±z birkaÃ§ nokta olan `useState`, `useRef` ve child componente prop gÃ¶ndermeyi Ã¶ÄŸrenmiÅŸ olduk. Typescript ve React Ã¼zerine daha fazla yazÄ± istiyorsanÄ±z bana [twitter](https://twitter.com/uguremirmustafa) Ã¼zerinden ulaÅŸabilirsiniz. Her tÃ¼rlÃ¼ geri dÃ¶nÃ¼ÅŸÃ¼nÃ¼z benim iÃ§in deÄŸerli.

Ä°yi Ã§alÄ±ÅŸmalar! ğŸ¥³
